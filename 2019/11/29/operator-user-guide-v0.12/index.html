<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Operator SDK User Guide | 水果点心 | beautiful &amp; delicious</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="kubernetes,operator">
    <meta name="description" content="Operator SDK 用户指南 v0.12（翻译） 本指南介绍了使用 operator-sdk CLI 工具和控制器运行时库的 API 构建简单的 memcached-operator 的示例。 要了解如何使用 Ansible 或 Helm 创建 operator，查看 Ansible Operator 用户指南 或者 Helm Operator 用户指南。本文档的其余部分将展示如何在 Go">
<meta name="keywords" content="kubernetes,operator">
<meta property="og:type" content="article">
<meta property="og:title" content="Operator SDK User Guide">
<meta property="og:url" content="https://luolizhi.github.io/2019/11/29/operator-user-guide-v0.12/index.html">
<meta property="og:site_name" content="水果点心">
<meta property="og:description" content="Operator SDK 用户指南 v0.12（翻译） 本指南介绍了使用 operator-sdk CLI 工具和控制器运行时库的 API 构建简单的 memcached-operator 的示例。 要了解如何使用 Ansible 或 Helm 创建 operator，查看 Ansible Operator 用户指南 或者 Helm Operator 用户指南。本文档的其余部分将展示如何在 Go">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-11-29T11:45:41.532Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Operator SDK User Guide">
<meta name="twitter:description" content="Operator SDK 用户指南 v0.12（翻译） 本指南介绍了使用 operator-sdk CLI 工具和控制器运行时库的 API 构建简单的 memcached-operator 的示例。 要了解如何使用 Ansible 或 Helm 创建 operator，查看 Ansible Operator 用户指南 或者 Helm Operator 用户指南。本文档的其余部分将展示如何在 Go">
    
        <link rel="alternate" type="application/atom+xml" title="水果点心" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/leaves7.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">lukey</h5>
          <a href="mailto:luolizhi1221@gmail.com" title="luolizhi1221@gmail.com" class="mail">luolizhi1221@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/luolizhi" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/haiyangbingan" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom"  >
                <i class="icon icon-lg icon-link"></i>
                Custom
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-info"></i>
                About
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Operator SDK User Guide</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Operator SDK User Guide</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-11-29T10:29:38.000Z" itemprop="datePublished" class="page-time">
  2019-11-29
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Operator-SDK-用户指南-v0-12（翻译）"><span class="post-toc-number">1.</span> <span class="post-toc-text">Operator SDK 用户指南 v0.12（翻译）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#先决条件"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">先决条件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#安装-Operator-SDK-CLI"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">安装 Operator SDK CLI</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#创建一个新项目"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">创建一个新项目</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#有关依赖管理的说明"><span class="post-toc-number">1.3.0.1.</span> <span class="post-toc-text">有关依赖管理的说明</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Vendoring"><span class="post-toc-number">1.3.0.1.1.</span> <span class="post-toc-text">Vendoring</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Operator-范围"><span class="post-toc-number">1.3.0.2.</span> <span class="post-toc-text">Operator 范围</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在集群中运行一个deploymet"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">1. 在集群中运行一个deploymet</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#创建一个-Memcached-CR"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">创建一个 Memcached CR</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#更新大小"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">更新大小</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#清理"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">清理</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进阶主题"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">进阶主题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#增加第三方资源到你的-operator-中"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">增加第三方资源到你的 operator 中</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#注册-Manager-的-scheme"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">注册 Manager 的 scheme</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在删除的时候做些清理工作"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">在删除的时候做些清理工作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Metrics"><span class="post-toc-number">1.5.4.</span> <span class="post-toc-text">Metrics</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#领导人选举"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">领导人选举</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leader-for-life"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">Leader for life</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Leader-with-lease"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">Leader with lease</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-operator-user-guide-v0.12"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Operator SDK User Guide</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-11-29 18:29:38" datetime="2019-11-29T10:29:38.000Z"  itemprop="datePublished">2019-11-29</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="Operator-SDK-用户指南-v0-12（翻译）"><a href="#Operator-SDK-用户指南-v0-12（翻译）" class="headerlink" title="Operator SDK 用户指南 v0.12（翻译）"></a>Operator SDK 用户指南 v0.12（翻译）</h1><!-- 
This guide walks through an example of building a simple memcached-operator using the operator-sdk CLI tool and controller-runtime library API. To learn how to use Ansible or Helm to create an operator, see the [Ansible Operator User Guide][ansible_user_guide] or the [Helm Operator User Guide][helm_user_guide]. The rest of this document will show how to program an operator in Go.
 -->
<p>本指南介绍了使用 operator-sdk CLI 工具和控制器运行时库的 API 构建简单的 memcached-operator 的示例。 要了解如何使用 Ansible 或 Helm 创建 operator，查看 <a href="./ansible/user-guide.md">Ansible Operator 用户指南</a> 或者 <a href="./helm/user-guide.md">Helm Operator 用户指南</a>。本文档的其余部分将展示如何在 Go 中编写 operator。</p>
<p><a href="https://github.com/operator-framework/operator-sdk/blob/v0.12.x/doc/user-guide.md" target="_blank" rel="noopener">原文链接</a></p>
<!-- 
## Prerequisites

- [git][git_tool]
- [go][go_tool] version v1.12+.
- [mercurial][mercurial_tool] version 3.9+
- [docker][docker_tool] version 17.03+.
- [kubectl][kubectl_tool] version v1.11.3+.
- Access to a Kubernetes v1.11.3+ cluster.

**Note**: This guide uses [minikube][minikube_tool] version v0.25.0+ as the local Kubernetes cluster and [quay.io][quay_link] for the public registry.
 -->
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul>
<li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git</a></li>
<li><a href="https://golang.org/dl/" target="_blank" rel="noopener">go</a> 版本 v1.12+.</li>
<li><a href="https://www.mercurial-scm.org/downloads" target="_blank" rel="noopener">mercurial</a> 版本 3.9+</li>
<li><a href="https://docs.docker.com/install/" target="_blank" rel="noopener">docker</a> 版本 17.03+.</li>
<li><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" target="_blank" rel="noopener">kubectl</a> 版本 v1.11.3+.</li>
<li>可以访问版本 v1.11.3+ Kubernetes 集群。</li>
</ul>
<p><strong>注意</strong>：本指南使用 <a href="https://github.com/kubernetes/minikube#installation" target="_blank" rel="noopener">minikube</a> 版本 v0.25.0+ 作为本地 Kubernetes 集群，同时使用 <a href="https://quay.io" target="_blank" rel="noopener">quay.io</a> 作为公共镜像仓库。</p>
<!-- 
## Install the Operator SDK CLI

Follow the steps in the [installation guide][install_guide] to learn how to install the Operator SDK CLI tool.

## Create a new project

Use the CLI to create a new memcached-operator project:
-->
<h2 id="安装-Operator-SDK-CLI"><a href="#安装-Operator-SDK-CLI" class="headerlink" title="安装 Operator SDK CLI"></a>安装 Operator SDK CLI</h2><p>请按照 <a href="./user/install-operator-sdk.md">安装指南</a> 中的步骤进行操作，以了解如何安装 Operator SDK CLI 工具。</p>
<h2 id="创建一个新项目"><a href="#创建一个新项目" class="headerlink" title="创建一个新项目"></a>创建一个新项目</h2><p>使用 CLI 创建一个新的 memcached-operator 项目：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p <span class="variable">$HOME</span>/projects</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$HOME</span>/projects</span><br><span class="line">$ operator-sdk new memcached-operator --repo=github.com/example-inc/memcached-operator</span><br><span class="line">$ <span class="built_in">cd</span> memcached-operator</span><br></pre></td></tr></table></figure>
<!-- 
To learn about the project directory structure, see [project layout][layout_doc] doc.
 -->
<p>要了解项目目录结构，请查看 <a href="./project_layout.md">项目布局</a> 文档。</p>
<!-- 
#### A note on dependency management

`operator-sdk new` generates a `go.mod` file to be used with [Go modules][go_mod_wiki]. The `--repo=<path>` flag is required when creating a project outside of `$GOPATH/src`, as scaffolded files require a valid module path. Ensure you activate module support before using the SDK. From the [Go modules Wiki][go_mod_wiki]:

> You can activate module support in one of two ways:
> - Invoke the go command in a directory with a valid go.mod file in the current directory or any parent of it and the environment variable GO111MODULE unset (or explicitly set to auto).
> - Invoke the go command with GO111MODULE=on environment variable set.
 -->
<h4 id="有关依赖管理的说明"><a href="#有关依赖管理的说明" class="headerlink" title="有关依赖管理的说明"></a>有关依赖管理的说明</h4><p><code>operator-sdk new</code> 生成一个 <code>go.mod</code> 文件，该文件供 <a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Go modules</a> 使用。 当在 <code>$GOPATH/src</code> 路径之外创建项目时， 必须使用 <code>--repo=&lt;path&gt;</code> 参数，因为脚手架文件需要一个有效的模块路径。使用 SDK 之前，请确认开启支持 go module。从 <a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Go modules Wiki</a> 中：</p>
<blockquote>
<p>你能通过以下两种方式之一开启支持 go module：</p>
<ul>
<li>调用 go 命令的当前目录或其任何父目录中具有有效 go.mod 文件，并且未设置环境变量 GO111MODULE（或将其显式设置为 auto）。</li>
<li>使用 go 命令设置 GO111MODULE=on 环境变量。</li>
</ul>
</blockquote>
<!-- 
##### Vendoring

By default `--vendor=false`, so an operator's dependencies are downloaded and cached in the Go modules cache. Calls to `go {build,clean,get,install,list,run,test}` by `operator-sdk` subcommands will use an external modules directory. Execute `go help modules` for more information.

The Operator SDK can create a [`vendor`][go_vendoring] directory for Go dependencies if the project is initialized with `--vendor=true`.
-->
<h5 id="Vendoring"><a href="#Vendoring" class="headerlink" title="Vendoring"></a>Vendoring</h5><p>默认情况下 <code>--vendor=false</code>，因此 operator 的依赖项下载并缓存在 Go modules 缓存中。通过 <code>operator-sdk</code> 子命令对 <code>go {build,clean,get,install,list,run,test}</code> 的条用将会使用一个外部 modules 目录。执行 <code>go help modules</code> 获取更多信息。</p>
<p>项目初始化使用 <code>--vendor=true</code> 参数，Operator SDK 能够为 Go 项目依赖创建 <a href="https://blog.gopheracademy.com/advent-2015/vendor-folder/" target="_blank" rel="noopener"><code>vendor</code></a> 文件夹。</p>
<!-- 
#### Operator scope

Read the [operator scope][operator_scope] documentation on how to run your operator as namespace-scoped vs cluster-scoped.
 -->
<h4 id="Operator-范围"><a href="#Operator-范围" class="headerlink" title="Operator 范围"></a>Operator 范围</h4><p>阅读 <a href="./operator-scope.md">operator scope</a> 文档，了解如何在命令空间范围或者集群范围内运行你的operator。</p>
<!-- 
### Manager
The main program for the operator `cmd/manager/main.go` initializes and runs the [Manager][manager_go_doc].

The Manager will automatically register the scheme for all custom resources defined under `pkg/apis/...` and run all controllers under `pkg/controller/...`.

The Manager can restrict the namespace that all controllers will watch for resources:
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mgr, err := manager.New(cfg, manager.Options&#123;Namespace: namespace&#125;)</span><br></pre></td></tr></table></figure>
<p>By default this will be the namespace that the operator is running in. To watch all namespaces leave the namespace option empty:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mgr, err := manager.New(cfg, manager.Options&#123;Namespace: <span class="string">""</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p>By default the main program will set the manager’s namespace using the value of <code>WATCH_NAMESPACE</code> env defined in <code>deploy/operator.yaml</code>.<br> –&gt;</p>
<h3 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h3><p>operator 的主程序位于 <code>cmd/manager/main.go</code> 会初始化并运行 <a href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/manager#Manager">Manager</a>。</p>
<p>Manager 会自动为 <code>pkg/apis/...</code> 下所有自定义资源注册 scheme，并运行 <code>pkg/controller/...</code> 下所有的控制器。</p>
<p>Manager 可以限制所有控制器将监听资源的名称空间：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mgr, err := manager.New(cfg, manager.Options&#123;Namespace: namespace&#125;)</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，operator 只会监听其运行的名称空间的资源。要监听所有名称空间，请将名称空间选项留空：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mgr, err := manager.New(cfg, manager.Options&#123;Namespace: <span class="string">""</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，主程序将会使用定义在 <code>deploy/operator.yaml</code> 中 <code>WATCH_NAMESPACE</code> 的值设置 manager 的名称空间的值。</p>
<!-- 
## Add a new Custom Resource Definition

Add a new Custom Resource Definition(CRD) API called Memcached, with APIVersion `cache.example.com/v1alpha1` and Kind `Memcached`.

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk add api --api-version=cache.example.com/v1alpha1 --kind=Memcached</span><br></pre></td></tr></table></figure>
<p>This will scaffold the Memcached resource API under <code>pkg/apis/cache/v1alpha1/...</code>.<br> –&gt;</p>
<h2 id="添加新的自定义资源定义"><a href="#添加新的自定义资源定义" class="headerlink" title="添加新的自定义资源定义"></a>添加新的自定义资源定义</h2><p>使用 APIVersion 值为 <code>cache.example.com/v1alpha1</code> 和 Kind 值为 <code>Memcached</code> 来添加一个名为 Memcached 的自定义资源定义（CRD）API。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk add api --api-version=cache.example.com/v1alpha1 --kind=Memcached</span><br></pre></td></tr></table></figure>
<p>这将在 <code>pkg/apis/cache/v1alpha1/...</code> 目录下生成 Memcached 资源 API。</p>
<!-- 
### Define the spec and status

Modify the spec and status of the `Memcached` Custom Resource(CR) at `pkg/apis/cache/v1alpha1/memcached_types.go`:

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MemcachedSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Size is the size of the memcached deployment</span></span><br><span class="line">	Size <span class="keyword">int32</span> <span class="string">`json:"size"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MemcachedStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Nodes are the names of the memcached pods</span></span><br><span class="line">	Nodes []<span class="keyword">string</span> <span class="string">`json:"nodes"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>After modifying the <code>*_types.go</code> file always run the following command to update the generated code for that resource type:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk generate k8s</span><br></pre></td></tr></table></figure>
<p> –&gt;</p>
<h3 id="定义规格和状态"><a href="#定义规格和状态" class="headerlink" title="定义规格和状态"></a>定义规格和状态</h3><p>在 <code>pkg/apis/cache/v1alpha1/memcached_types.go</code> 处修改  <code>Memcached</code> 自定义资源(CR) 的spec 和 status：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MemcachedSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Size is the size of the memcached deployment</span></span><br><span class="line">	Size <span class="keyword">int32</span> <span class="string">`json:"size"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MemcachedStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Nodes are the names of the memcached pods</span></span><br><span class="line">	Nodes []<span class="keyword">string</span> <span class="string">`json:"nodes"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 <code>*_types.go</code> 之后，始终运行以下命令更新该资源类型的生成代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk generate k8s</span><br></pre></td></tr></table></figure>
<!-- 
### OpenAPI validation
To update the OpenAPI validation section in the CRD `deploy/crds/cache.example.com_memcacheds_crd.yaml`, run the following command.

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> operator-sdk generate openapi</span></span><br></pre></td></tr></table></figure>
<p>This validation section allows Kubernetes to validate the properties in a Memcached Custom Resource when it is created or updated. An example of the generated YAML is as follows:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">validation:</span></span><br><span class="line">    <span class="attr">openAPIV3Schema:</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">properties:</span></span><br><span class="line">            <span class="attr">size:</span></span><br><span class="line">              <span class="attr">format:</span> <span class="string">int32</span></span><br><span class="line">              <span class="attr">type:</span> <span class="string">integer</span></span><br></pre></td></tr></table></figure>
<p>To learn more about OpenAPI v3.0 validation schemas in Custom Resource Definitions, refer to the <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#specifying-a-structural-schema">Kubernetes Documentation</a>.<br> –&gt;</p>
<h3 id="OpenAPI-验证"><a href="#OpenAPI-验证" class="headerlink" title="OpenAPI 验证"></a>OpenAPI 验证</h3><p>要更新CRD <code>deploy/crds/cache.example.com_memcacheds_crd.yaml</code> 中的 OpenAPI 验证部分，请运行以下命令。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> operator-sdk generate openapi</span></span><br></pre></td></tr></table></figure>
<p>该验证部分允许 Kubernetes 在创建或更新 Memcached 自定义资源时验证其属性。 生成的 YAML 的示例如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">validation:</span></span><br><span class="line">    <span class="attr">openAPIV3Schema:</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">properties:</span></span><br><span class="line">            <span class="attr">size:</span></span><br><span class="line">              <span class="attr">format:</span> <span class="string">int32</span></span><br><span class="line">              <span class="attr">type:</span> <span class="string">integer</span></span><br></pre></td></tr></table></figure>
<p>要在 “自定义资源定义” 中了解有关 OpenAPI v3.0 验证架构的更多信息，请参考 <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#specifying-a-structural-schema">Kubernetes Documentation</a> 文档。</p>
<!-- 
## Add a new Controller

Add a new [Controller][controller-go-doc] to the project that will watch and reconcile the Memcached resource:

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk add controller --api-version=cache.example.com/v1alpha1 --kind=Memcached</span><br></pre></td></tr></table></figure>
<p>This will scaffold a new Controller implementation under <code>pkg/controller/memcached/...</code>.</p>
<p>For this example replace the generated Controller file <code>pkg/controller/memcached/memcached_controller.go</code> with the example <a href="../example/memcached-operator/memcached_controller.go.tmpl"><code>memcached_controller.go</code></a> implementation.</p>
<p>The example Controller executes the following reconciliation logic for each <code>Memcached</code> CR:</p>
<ul>
<li>Create a memcached Deployment if it doesn’t exist</li>
<li>Ensure that the Deployment size is the same as specified by the <code>Memcached</code> CR spec</li>
<li>Update the <code>Memcached</code> CR status using the status writer with the names of the memcached pods</li>
</ul>
<p>The next two subsections explain how the Controller watches resources and how the reconcile loop is triggered. Skip to the <a href="#build-and-run-the-operator">Build</a> section to see how to build and run the operator.<br> –&gt;</p>
<h2 id="添加一个新的控制器"><a href="#添加一个新的控制器" class="headerlink" title="添加一个新的控制器"></a>添加一个新的控制器</h2><p>向项目中增加一个新的 <a href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg#hdr-Controller">控制器</a>，该项目就能监听并调和 Memcached 资源：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk add controller --api-version=cache.example.com/v1alpha1 --kind=Memcached</span><br></pre></td></tr></table></figure>
<p>这将在 <code>pkg/controller/memcached/...</code> 目录下生成新的控制器实现。</p>
<p>在此示例中，将生成的控制器文件 <code>pkg/controller/memcached/memcached_controller.go</code> 替换为示例 <a href="../example/memcached-operator/memcached_controller.go.tmpl"><code>memcached_controller.go</code></a> 实现。</p>
<p>示例控制器对每一个 <code>Memcached</code> CR 执行以下调和逻辑：</p>
<ul>
<li>创建 memcached Deployment（如果不存在）</li>
<li>确认 Deployment 的大小与  <code>Memcached</code> CR spec 的值大小相同</li>
<li>使用状态写入器将memcached pods 名称更新 <code>Memcached</code> CR status 值</li>
</ul>
<p>接下来的两个小节说明了 Controller 如何监听资源以及如何触发调和循环。跳至 <a href="#build-and-run-the-operator">Build</a> 部分以了解如何构建和运行operator。 </p>
<!-- 
### Resources watched by the Controller

Inspect the Controller implementation at `pkg/controller/memcached/memcached_controller.go` to see how the Controller watches resources.

The first watch is for the Memcached type as the primary resource. For each Add/Update/Delete event the reconcile loop will be sent a reconcile `Request` (a namespace/name key) for that Memcached object:

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err := c.Watch(</span><br><span class="line">  &amp;source.Kind&#123;Type: &amp;cachev1alpha1.Memcached&#123;&#125;&#125;, &amp;handler.EnqueueRequestForObject&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>The next watch is for Deployments but the event handler will map each event to a reconcile <code>Request</code> for the owner of the Deployment. Which in this case is the Memcached object for which the Deployment was created. This allows the controller to watch Deployments as a secondary resource.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := c.Watch(&amp;source.Kind&#123;Type: &amp;appsv1.Deployment&#123;&#125;&#125;, &amp;handler.EnqueueRequestForOwner&#123;</span><br><span class="line">    IsController: <span class="literal">true</span>,</span><br><span class="line">    OwnerType:    &amp;cachev1alpha1.Memcached&#123;&#125;,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p> –&gt;</p>
<h3 id="控制器监听的资源"><a href="#控制器监听的资源" class="headerlink" title="控制器监听的资源"></a>控制器监听的资源</h3><p>在 <code>pkg/controller/memcached/memcached_controller.go</code> 上检查 Controller 的实现，以查看 Controller 如何监听资源。</p>
<p>首先要注意的是将 Memcached 类型作为一级资源。对于每一个 Add/Update/Delete 事件，将向调和循环发送该 Memcached 对象的调和 <code>Request</code> (一个 名称空间/名字 关键字)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err := c.Watch(</span><br><span class="line">  &amp;source.Kind&#123;Type: &amp;cachev1alpha1.Memcached&#123;&#125;&#125;, &amp;handler.EnqueueRequestForObject&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>下一个监听对象是 Deployments，但事件处理程序会将每个事件映射到 Deployment 所有者的调和 <code>Request</code> 中。 在本例中就是 Memcached 对象，因为 Memcached 对象创建了 Deployment 。 这使控制器可以将 Deployment 视为二级资源来监听。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := c.Watch(&amp;source.Kind&#123;Type: &amp;appsv1.Deployment&#123;&#125;&#125;, &amp;handler.EnqueueRequestForOwner&#123;</span><br><span class="line">    IsController: <span class="literal">true</span>,</span><br><span class="line">    OwnerType:    &amp;cachev1alpha1.Memcached&#123;&#125;,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<!-- 
#### Controller configurations

There are a number of useful configurations that can be made when initialzing a controller and declaring the watch parameters. For more details on these configurations consult the upstream [controller godocs][controller_godocs]. 

- Set the max number of concurrent Reconciles for the controller via the [`MaxConcurrentReconciles`][controller_options]  option. Defaults to 1.
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, err := controller.New(<span class="string">"memcached-controller"</span>, mgr, controller.Options&#123;</span><br><span class="line"> MaxConcurrentReconciles: <span class="number">2</span>,</span><br><span class="line"> ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>Filter watch events using <a href="./user/event-filtering.md">predicates</a></li>
<li>Choose the type of <a href="https://godoc.org/sigs.k8s.io/controller-runtime/pkg/handler#hdr-EventHandlers">EventHandler</a> to change how a watch event will translate to reconcile requests for the reconcile loop. For operator relationships that are more complex than primary and secondary resources, the <a href="https://godoc.org/sigs.k8s.io/controller-runtime/pkg/handler#EnqueueRequestsFromMapFunc"><code>EnqueueRequestsFromMapFunc</code></a> handler can be used to transform a watch event into an arbitrary set of reconcile requests.<br>–&gt;<h4 id="Controller-配置"><a href="#Controller-配置" class="headerlink" title="Controller 配置"></a>Controller 配置</h4></li>
</ul>
<p>初始化控制器和声明监听参数时，可以进行许多有用的配置。有关这些配置的更多详细信息，请查看上游 <a href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/controller">controller godocs</a> 文档。</p>
<ul>
<li><p>通过 <a href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/controller#Options"><code>MaxConcurrentReconciles</code></a> 参数设置控制器的最大并发调和数。默认值是1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, err := controller.New(<span class="string">"memcached-controller"</span>, mgr, controller.Options&#123;</span><br><span class="line"> MaxConcurrentReconciles: <span class="number">2</span>,</span><br><span class="line"> ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a href="./user/event-filtering.md">predicates</a> 过滤监听事件</p>
</li>
<li>选择 <a href="https://godoc.org/sigs.k8s.io/controller-runtime/pkg/handler#hdr-EventHandlers">EventHandler</a> 的类型来修改监听事件将如何转换为调和循环的调和请求。 operator 的关系比一级资源和二级资源更加复杂，使用 <a href="https://godoc.org/sigs.k8s.io/controller-runtime/pkg/handler#EnqueueRequestsFromMapFunc"><code>EnqueueRequestsFromMapFunc</code></a> 能将监听事件转换成任意的调和请求集。</li>
</ul>
<!-- 
### Reconcile loop

Every Controller has a Reconciler object with a `Reconcile()` method that implements the reconcile loop. The reconcile loop is passed the [`Request`][request-go-doc] argument which is a Namespace/Name key used to lookup the primary resource object, Memcached, from the cache:

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReconcileMemcached)</span> <span class="title">Reconcile</span><span class="params">(request reconcile.Request)</span> <span class="params">(reconcile.Result, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Lookup the Memcached instance for this reconcile request</span></span><br><span class="line">  memcached := &amp;cachev1alpha1.Memcached&#123;&#125;</span><br><span class="line">  err := r.client.Get(context.TODO(), request.NamespacedName, memcached)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Based on the return values, <a href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/reconcile#Result"><code>Result</code></a> and error, the <code>Request</code> may be requeued and the reconcile loop may be triggered again:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reconcile successful - don't requeue</span></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Reconcile failed due to error - requeue</span></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line"><span class="comment">// Requeue for any reason other than error</span></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;Requeue: <span class="literal">true</span>&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>You can set the <code>Result.RequeueAfter</code> to requeue the <code>Request</code> after a grace period as well:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reconcile for any reason than error after 5 seconds</span></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;RequeueAfter: time.Second*<span class="number">5</span>&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong> Returning <code>Result</code> with <code>RequeueAfter</code> set is how you can periodically reconcile a CR.</p>
<p>For a guide on Reconcilers, Clients, and interacting with resource Events, see the <a href="./user/client.md">Client API doc</a>.<br> –&gt;</p>
<h3 id="调和循环"><a href="#调和循环" class="headerlink" title="调和循环"></a>调和循环</h3><p>每个 Controller 都有一个 Reconciler 对象，该对象有实现了调和循环的 <code>Reconcile()</code> 方法。 该方法接受 <a href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/reconcile#Request"><code>Request</code></a> 参数，这个参数的 Namespace/Name 值用来从缓存中查找一级资源对象 Memcached：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReconcileMemcached)</span> <span class="title">Reconcile</span><span class="params">(request reconcile.Request)</span> <span class="params">(reconcile.Result, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Lookup the Memcached instance for this reconcile request</span></span><br><span class="line">  memcached := &amp;cachev1alpha1.Memcached&#123;&#125;</span><br><span class="line">  err := r.client.Get(context.TODO(), request.NamespacedName, memcached)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据返回值，<a href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/reconcile#Result"><code>Result</code></a> 和 error，这个 <code>Request</code> 可能会重新入队列并可能再次触发协和循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reconcile successful - don't requeue</span></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Reconcile failed due to error - requeue</span></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line"><span class="comment">// Requeue for any reason other than error</span></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;Requeue: <span class="literal">true</span>&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>你还可以将 <code>Result.RequeueAfter</code> 设置成在一段时间后 <code>Request</code> 重新进入队列：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reconcile for any reason than error after 5 seconds</span></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;RequeueAfter: time.Second*<span class="number">5</span>&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 通过设置返回值 <code>Result</code> 中的 <code>RequeueAfter</code> 可以定期的调和一个 CR 资源。 </p>
<p>有关调和器，客户端以及与资源事件的交互指南，请查看 <a href="./user/client.md">Client API doc</a>。</p>
<!-- 
## Build and run the operator

Before running the operator, the CRD must be registered with the Kubernetes apiserver:

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f deploy/crds/cache.example.com_memcacheds_crd.yaml</span><br></pre></td></tr></table></figure>
<p>Once this is done, there are two ways to run the operator:</p>
<ul>
<li>As a Deployment inside a Kubernetes cluster</li>
<li>As Go program outside a cluster<br>–&gt;<h2 id="构建并运行-operator"><a href="#构建并运行-operator" class="headerlink" title="构建并运行 operator"></a>构建并运行 operator</h2></li>
</ul>
<p>在运行 operator 之前，CRD 必须注册到 Kubernetes apiserver 中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f deploy/crds/cache.example.com_memcacheds_crd.yaml</span><br></pre></td></tr></table></figure>
<p>完成此操作后，有两种方法可以运行 operator：</p>
<ul>
<li>在 Kubernetes 集群中的deploymet</li>
<li>在 Kubernetes 集外的 Go 程序</li>
</ul>
<!-- 
### 1. Run as a Deployment inside the cluster

**Note**: `operator-sdk build` invokes `docker build` by default, and optionally `buildah bud`. If using `buildah`, skip to the `operator-sdk build` invocation instructions below. If using `docker`, make sure your docker daemon is running and that you can run the docker client without sudo. You can check if this is the case by running `docker version`, which should complete without errors. Follow instructions for your OS/distribution on how to start the docker daemon and configure your access permissions, if needed.

**Note**: If a `vendor/` directory is present, run
 -->
<h3 id="1-在集群中运行一个deploymet"><a href="#1-在集群中运行一个deploymet" class="headerlink" title="1. 在集群中运行一个deploymet"></a>1. 在集群中运行一个deploymet</h3><p><strong>注意</strong>: 默认情况下，<code>operator-sdk build</code> 会调用 <code>docker build</code>，也可以选择调用 <code>buildah bud</code>。如果使用 <code>buildah</code>，请跳到下面的 <code>operator-sdk build</code> 调用说明。如果使用 <code>docker</code>，确认你的 docker 守护进程正在运行，并且可以在没有 sudo 的情况下运行 docker 客户端。您可以通过运行 docker version 来检查是否存在这种情况，该版本应该正确无误。 请根据你的 OS/distribution 上的说明，了解如何启动 docker 守护进程并根据需要配置访问权限。</p>
<p><strong>注意</strong>: 如果存在 <code>vendor/</code> 目录，运行下面命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go mod vendor</span><br></pre></td></tr></table></figure>
<!-- 
before building the memcached-operator image.

Build the memcached-operator image and push it to a registry:
 -->
<p>在构建 memcached-operator 镜像之前。</p>
<p>构建 memcached-operator 镜像并推送到镜像仓库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk build quay.io/example/memcached-operator:v0.0.1</span><br><span class="line">$ sed -i <span class="string">'s|REPLACE_IMAGE|quay.io/example/memcached-operator:v0.0.1|g'</span> deploy/operator.yaml</span><br><span class="line">$ docker push quay.io/example/memcached-operator:v0.0.1</span><br></pre></td></tr></table></figure></p>
<!-- 
**Note**
If you are performing these steps on OSX, use the following `sed` command instead:
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i <span class="string">""</span> <span class="string">'s|REPLACE_IMAGE|quay.io/example/memcached-operator:v0.0.1|g'</span> deploy/operator.yaml</span><br></pre></td></tr></table></figure>
<p>The Deployment manifest is generated at <code>deploy/operator.yaml</code>. Be sure to update the deployment image as shown above since the default is just a placeholder.</p>
<p>Setup RBAC and deploy the memcached-operator:<br> –&gt;<br><strong>注意</strong><br>如果你是在 OSX 系统上执行，使用下面的 <code>sed</code> 命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i <span class="string">""</span> <span class="string">'s|REPLACE_IMAGE|quay.io/example/memcached-operator:v0.0.1|g'</span> deploy/operator.yaml</span><br></pre></td></tr></table></figure></p>
<p>部署清单在 <code>deploy/operator.yaml</code> 目录中生成。由于默认值是一个占位符，因此请确认按照上述命令更新 deployment 镜像。</p>
<p>设置 RBAC 然后部署 memcached-operator：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f deploy/service_account.yaml</span><br><span class="line">$ kubectl create -f deploy/role.yaml</span><br><span class="line">$ kubectl create -f deploy/role_binding.yaml</span><br><span class="line">$ kubectl create -f deploy/operator.yaml</span><br></pre></td></tr></table></figure>
<!-- 
Verify that the memcached-operator is up and running:
 -->
<p>验证 memcached-operator 已经启动并正在运行:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deployment</span><br><span class="line">NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">memcached-operator       1         1         1            1           1m</span><br></pre></td></tr></table></figure>
<!-- 
### 2. Run locally outside the cluster

This method is preferred during development cycle to deploy and test faster.

Set the name of the operator in an environment variable:

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> OPERATOR_NAME=memcached-operator</span><br></pre></td></tr></table></figure>
<p>Run the operator locally with the default Kubernetes config file present at <code>$HOME/.kube/config</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk up <span class="built_in">local</span> --namespace=default</span><br><span class="line">2018/09/30 23:10:11 Go Version: go1.10.2</span><br><span class="line">2018/09/30 23:10:11 Go OS/Arch: darwin/amd64</span><br><span class="line">2018/09/30 23:10:11 operator-sdk Version: 0.0.6+git</span><br><span class="line">2018/09/30 23:10:12 Registering Components.</span><br><span class="line">2018/09/30 23:10:12 Starting the Cmd.</span><br></pre></td></tr></table></figure>
<p>You can use a specific kubeconfig via the flag <code>--kubeconfig=&lt;path/to/kubeconfig&gt;</code>.<br> –&gt;</p>
<h3 id="2-在集群外本地运行"><a href="#2-在集群外本地运行" class="headerlink" title="2. 在集群外本地运行"></a>2. 在集群外本地运行</h3><p>在开发周期中，首选此方法来更快地部署和测试。</p>
<p>设置一个 operator 名称的环境变量：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> OPERATOR_NAME=memcached-operator</span><br></pre></td></tr></table></figure>
<p>使用保存 <code>$HOME/.kube/config</code> 中的默认 kubernetes 配置文件在本地运行 operator：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk up <span class="built_in">local</span> --namespace=default</span><br><span class="line">2018/09/30 23:10:11 Go Version: go1.10.2</span><br><span class="line">2018/09/30 23:10:11 Go OS/Arch: darwin/amd64</span><br><span class="line">2018/09/30 23:10:11 operator-sdk Version: 0.0.6+git</span><br><span class="line">2018/09/30 23:10:12 Registering Components.</span><br><span class="line">2018/09/30 23:10:12 Starting the Cmd.</span><br></pre></td></tr></table></figure>
<p>你可以通过参数 <code>--kubeconfig=&lt;path/to/kubeconfig&gt;</code> 指定特定的 kubeconfig 使用。</p>
<!-- 

## Create a Memcached CR

Create the example `Memcached` CR that was generated at `deploy/crds/cache.example.com_v1alpha1_memcached_cr.yaml`:
 -->
<h2 id="创建一个-Memcached-CR"><a href="#创建一个-Memcached-CR" class="headerlink" title="创建一个 Memcached CR"></a>创建一个 Memcached CR</h2><p>示例 <code>Memcached</code> CR 会生成在 <code>deploy/crds/cache.example.com_v1alpha1_memcached_cr.yaml</code> 中：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat deploy/crds/cache.example.com_v1alpha1_memcached_cr.yaml</span><br><span class="line">apiVersion: <span class="string">"cache.example.com/v1alpha1"</span></span><br><span class="line">kind: <span class="string">"Memcached"</span></span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="string">"example-memcached"</span></span><br><span class="line">spec:</span><br><span class="line">  size: 3</span><br><span class="line"></span><br><span class="line">$ kubectl apply -f deploy/crds/cache.example.com_v1alpha1_memcached_cr.yaml</span><br></pre></td></tr></table></figure></p>
<!-- 
Ensure that the memcached-operator creates the deployment for the CR:
 -->
<p>确认 memcached-operator 为 CR 创建了 deployment：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deployment</span><br><span class="line">NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">memcached-operator       1         1         1            1           2m</span><br><span class="line">example-memcached        3         3         3            3           1m</span><br></pre></td></tr></table></figure>
<!-- 
Check the pods and CR status to confirm the status is updated with the memcached pod names:
 -->
<p>检查 pods 和 CR 的状态以确认其状态已经用 memcached pod 名称更新了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME                                  READY     STATUS    RESTARTS   AGE</span><br><span class="line">example-memcached-6fd7c98d8-7dqdr     1/1       Running   0          1m</span><br><span class="line">example-memcached-6fd7c98d8-g5k7v     1/1       Running   0          1m</span><br><span class="line">example-memcached-6fd7c98d8-m7vn7     1/1       Running   0          1m</span><br><span class="line">memcached-operator-7cc7cfdf86-vvjqk   1/1       Running   0          2m</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get memcached/example-memcached -o yaml</span><br><span class="line">apiVersion: cache.example.com/v1alpha1</span><br><span class="line">kind: Memcached</span><br><span class="line">metadata:</span><br><span class="line">  clusterName: <span class="string">""</span></span><br><span class="line">  creationTimestamp: 2018-03-31T22:51:08Z</span><br><span class="line">  generation: 0</span><br><span class="line">  name: example-memcached</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: <span class="string">"245453"</span></span><br><span class="line">  selfLink: /apis/cache.example.com/v1alpha1/namespaces/default/memcacheds/example-memcached</span><br><span class="line">  uid: 0026cc97-3536-11e8-bd83-0800274106a1</span><br><span class="line">spec:</span><br><span class="line">  size: 3</span><br><span class="line">status:</span><br><span class="line">  nodes:</span><br><span class="line">  - example-memcached-6fd7c98d8-7dqdr</span><br><span class="line">  - example-memcached-6fd7c98d8-g5k7v</span><br><span class="line">  - example-memcached-6fd7c98d8-m7vn7</span><br></pre></td></tr></table></figure>
<!-- 
### Update the size

Change the `spec.size` field in the memcached CR from 3 to 4 and apply the change:
 -->
<h3 id="更新大小"><a href="#更新大小" class="headerlink" title="更新大小"></a>更新大小</h3><p>将 memcached CR 中的 <code>spec.size</code> 字段从3更改为4，并应用更改：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat deploy/crds/cache.example.com_v1alpha1_memcached_cr.yaml</span><br><span class="line">apiVersion: <span class="string">"cache.example.com/v1alpha1"</span></span><br><span class="line">kind: <span class="string">"Memcached"</span></span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="string">"example-memcached"</span></span><br><span class="line">spec:</span><br><span class="line">  size: 4</span><br><span class="line"></span><br><span class="line">$ kubectl apply -f deploy/crds/cache.example.com_v1alpha1_memcached_cr.yaml</span><br></pre></td></tr></table></figure>
<!-- 
Confirm that the operator changes the deployment size:
 -->
<p>确认 operator 改变了 deployment 的大小：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deployment</span><br><span class="line">NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">example-memcached    4         4         4            4           5m</span><br></pre></td></tr></table></figure>
<!-- 
### Cleanup

Clean up the resources:
 -->
<h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>清理资源：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f deploy/crds/cache.example.com_v1alpha1_memcached_cr.yaml</span><br><span class="line">$ kubectl delete -f deploy/operator.yaml</span><br><span class="line">$ kubectl delete -f deploy/role_binding.yaml</span><br><span class="line">$ kubectl delete -f deploy/role.yaml</span><br><span class="line">$ kubectl delete -f deploy/service_account.yaml</span><br></pre></td></tr></table></figure>
<!-- 
## Advanced Topics

### Adding 3rd Party Resources To Your Operator

The operator's Manager supports the Core Kubernetes resource types as found in the client-go [scheme][scheme_package] package and will also register the schemes of all custom resource types defined in your project under `pkg/apis`.
 -->
<h2 id="进阶主题"><a href="#进阶主题" class="headerlink" title="进阶主题"></a>进阶主题</h2><h3 id="增加第三方资源到你的-operator-中"><a href="#增加第三方资源到你的-operator-中" class="headerlink" title="增加第三方资源到你的 operator 中"></a>增加第三方资源到你的 operator 中</h3><p>operator 的 Manager 支持在 client-go <a href="https://github.com/kubernetes/client-go/blob/master/kubernetes/scheme/register.go" target="_blank" rel="noopener">scheme</a> 包中找到 Kubernetes 核心资源类型，并将你项目中 <code>pkg/apis</code> 目录下定义的所有自定义资源类型的 schemes 注册到 Kubernetes apiserver 中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"github.com/example-inc/memcached-operator/pkg/apis"</span></span><br><span class="line">  ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup Scheme for all resources</span></span><br><span class="line"><span class="keyword">if</span> err := apis.AddToScheme(mgr.GetScheme()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Error(err, <span class="string">""</span>)</span><br><span class="line">  os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<!-- 
To add a 3rd party resource to an operator, you must add it to the Manager's scheme. By creating an `AddToScheme()` method or reusing one you can easily add a resource to your scheme. An [example][deployments_register] shows that you define a function and then use the [runtime][runtime_package] package to create a `SchemeBuilder`.

#### Register with the Manager's scheme

Call the `AddToScheme()` function for your 3rd party resource and pass it the Manager's scheme via `mgr.GetScheme()`.

Example:
 -->
<p>要将第三方资源添加到 operator 中，你必须将其添加到 Manager’s scheme 中。通过创建一个 <code>AddToScheme()</code> 方法或者重用一个方法，你可以轻松地将资源加到你的 scheme 中。一个<a href="https://github.com/kubernetes/api/blob/master/apps/v1/register.go#L41" target="_blank" rel="noopener">示例]</a> 显示你定义一个函数，然后使用 <a href="https://godoc.org/k8s.io/apimachinery/pkg/runtime" target="_blank" rel="noopener">runtime</a> 包创建一个 <code>SchemeBuilder</code>。</p>
<h3 id="注册-Manager-的-scheme"><a href="#注册-Manager-的-scheme" class="headerlink" title="注册 Manager 的 scheme"></a>注册 Manager 的 scheme</h3><p>为你的第三方资源调用 <code>AddToScheme()</code> 方法，并通过 <code>mgr.GetScheme()</code> 将其传递给 Manager’s scheme。</p>
<p>示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  routev1 <span class="string">"github.com/openshift/api/route/v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Adding the routev1</span></span><br><span class="line">  <span class="keyword">if</span> err := routev1.AddToScheme(mgr.GetScheme()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Error(err, <span class="string">""</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setup all Controllers</span></span><br><span class="line">  <span class="keyword">if</span> err := controller.AddToManager(mgr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Error(err, <span class="string">""</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<!--
**NOTES:**

* After adding new import paths to your operator project, run `go mod vendor` if a `vendor/` directory is present in the root of your project directory to fulfill these dependencies.
* Your 3rd party resource needs to be added before add the controller in `"Setup all Controllers"`.

### Handle Cleanup on Deletion

To implement complex deletion logic, you can add a finalizer to your Custom Resource. This will prevent your Custom Resource from being
deleted until you remove the finalizer (ie, after your cleanup logic has successfully run). For more information, see the
[official Kubernetes documentation on finalizers](https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#finalizers).

**Example:**

The following is a snippet from the controller file under `pkg/controller/memcached/memcached_controller.go`
 -->
<p><strong>注意:</strong></p>
<ul>
<li>在将新的 import 路径添加到你的operator 项目中后，如果项目的根目录中存在 <code>vendor/</code> 目录，请运行 <code>go mod vendor</code> 以满足这些依赖。</li>
<li>需要先添加您的第三方资源，然后才能在 <code>&quot;Setup all Controllers&quot;</code> 中添加控制器。</li>
</ul>
<h3 id="在删除的时候做些清理工作"><a href="#在删除的时候做些清理工作" class="headerlink" title="在删除的时候做些清理工作"></a>在删除的时候做些清理工作</h3><p>要实现复杂的删除逻辑，你可以在自定义资源中增加一个 finalizer。这将阻止你的自定义资源被删除，直到你删除 finalizer（例如，在清理逻辑成功运行之后）。有关更多信息，请参考<a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#finalizers" target="_blank" rel="noopener">official Kubernetes documentation on finalizers</a>。</p>
<p><strong>示例：</strong></p>
<p>以下是 <code>pkg/controller/memcached/memcached_controller.go</code> 控制器文件的摘录。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> memcachedFinalizer = <span class="string">"finalizer.cache.example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReconcileMemcached)</span> <span class="title">Reconcile</span><span class="params">(request reconcile.Request)</span> <span class="params">(reconcile.Result, error)</span></span> &#123;</span><br><span class="line">	reqLogger := log.WithValues(<span class="string">"Request.Namespace"</span>, request.Namespace, <span class="string">"Request.Name"</span>, request.Name)</span><br><span class="line">	reqLogger.Info(<span class="string">"Reconciling Memcached"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fetch the Memcached instance</span></span><br><span class="line">	memcached := &amp;cachev1alpha1.Memcached&#123;&#125;</span><br><span class="line">	err := r.client.Get(context.TODO(), request.NamespacedName, memcached)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// If the resource is not found, that means all of</span></span><br><span class="line">		<span class="comment">// the finalizers have been removed, and the memcached</span></span><br><span class="line">		<span class="comment">// resource has been deleted, so there is nothing left</span></span><br><span class="line">		<span class="comment">// to do.</span></span><br><span class="line">		<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> reconcile.Result&#123;&#125;, fmt.Errorf(<span class="string">"could not fetch memcached instance: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if the Memcached instance is marked to be deleted, which is</span></span><br><span class="line">	<span class="comment">// indicated by the deletion timestamp being set.</span></span><br><span class="line">	isMemcachedMarkedToBeDeleted := memcached.GetDeletionTimestamp() != <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> isMemcachedMarkedToBeDeleted &#123;</span><br><span class="line">		<span class="keyword">if</span> contains(memcached.GetFinalizers(), memcachedFinalizer) &#123;</span><br><span class="line">			<span class="comment">// Run finalization logic for memcachedFinalizer. If the</span></span><br><span class="line">			<span class="comment">// finalization logic fails, don't remove the finalizer so</span></span><br><span class="line">			<span class="comment">// that we can retry during the next reconciliation.</span></span><br><span class="line">			<span class="keyword">if</span> err := r.finalizeMemcached(reqLogger, memcached); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Remove memcachedFinalizer. Once all finalizers have been</span></span><br><span class="line">			<span class="comment">// removed, the object will be deleted.</span></span><br><span class="line">			memcached.SetFinalizers(remove(memcached.GetFinalizers(), memcachedFinalizer))</span><br><span class="line">			err := r.client.Update(context.TODO(), memcached)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add finalizer for this CR</span></span><br><span class="line">	<span class="keyword">if</span> !contains(memcached.GetFinalizers(), memcachedFinalizer) &#123;</span><br><span class="line">		<span class="keyword">if</span> err := r.addFinalizer(reqLogger, memcached); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReconcileMemcached)</span> <span class="title">finalizeMemcached</span><span class="params">(reqLogger logr.Logger, m *cachev1alpha1.Memcached)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// TODO(user): Add the cleanup steps that the operator</span></span><br><span class="line">	<span class="comment">// needs to do before the CR can be deleted. Examples</span></span><br><span class="line">	<span class="comment">// of finalizers include performing backups and deleting</span></span><br><span class="line">	<span class="comment">// resources that are not owned by this CR, like a PVC.</span></span><br><span class="line">	reqLogger.Info(<span class="string">"Successfully finalized memcached"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReconcileMemcached)</span> <span class="title">addFinalizer</span><span class="params">(reqLogger logr.Logger, m *cachev1alpha1.Memcached)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	reqLogger.Info(<span class="string">"Adding Finalizer for the Memcached"</span>)</span><br><span class="line">	m.SetFinalizers(<span class="built_in">append</span>(m.GetFinalizers(), memcachedFinalizer))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update CR</span></span><br><span class="line">	err := r.client.Update(context.TODO(), m)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		reqLogger.Error(err, <span class="string">"Failed to update Memcached with finalizer"</span>)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(list []<span class="keyword">string</span>, s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">		<span class="keyword">if</span> v == s &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(list []<span class="keyword">string</span>, s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">		<span class="keyword">if</span> v == s &#123;</span><br><span class="line">			list = <span class="built_in">append</span>(list[:i], list[i+<span class="number">1</span>:]...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<!-- 
### Metrics

To learn about how metrics work in the Operator SDK read the [metrics section][metrics_doc] of the user documentation.
 -->
<h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p>要了解 operator SDK 中 metrics 如何工作，请阅读用户文档 <a href="./user/metrics/README.md">metrics section</a>。</p>
<!-- 
## Leader election

During the lifecycle of an operator it's possible that there may be more than 1 instance running at any given time e.g when rolling out an upgrade for the operator.
In such a scenario it is necessary to avoid contention between multiple operator instances via leader election so that only one leader instance handles the reconciliation while the other instances are inactive but ready to take over when the leader steps down.

There are two different leader election implementations to choose from, each with its own tradeoff.

- [Leader-for-life][leader_for_life]: The leader pod only gives up leadership (via garbage collection) when it is deleted. This implementation precludes the possibility of 2 instances mistakenly running as leaders (split brain). However, this method can be subject to a delay in electing a new leader. For instance when the leader pod is on an unresponsive or partitioned node, the [`pod-eviction-timeout`][pod_eviction_timeout] dictates how long it takes for the leader pod to be deleted from the node and step down (default 5m).
- [Leader-with-lease][leader_with_lease]: The leader pod periodically renews the leader lease and gives up leadership when it can't renew the lease. This implementation allows for a faster transition to a new leader when the existing leader is isolated, but there is a possibility of split brain in [certain situations][lease_split_brain].

By default the SDK enables the leader-for-life implementation. However you should consult the docs above for both approaches to consider the tradeoffs that make sense for your use case.

The following examples illustrate how to use the two options:
 -->
<h2 id="领导人选举"><a href="#领导人选举" class="headerlink" title="领导人选举"></a>领导人选举</h2><p>在 operator 的生命周期内，例如在为 operator 升级时，在任何给定的时间可能有多个实例在运行。<br>在这种情况下，有必要避免通过领导者选举在多个 operator 实例之间发生争用，以便只有一个领导者实例处理调和，而其他实例处于非活动状态，但准备好在领导者下台时接管。</p>
<p>有两种不同的领导者选举实现方式可供选择，每种实现方式都有其自身的取舍。</p>
<ul>
<li><a href="https://godoc.org/github.com/operator-framework/operator-sdk/pkg/leader" target="_blank" rel="noopener">Leader-for-life</a>：领导者 pod 仅在被删除时才放弃领导（通过垃圾回收）。此实现避免了 2 个实例错误地作为领导者运行（脑裂）的可能性。但是，此方法可能会导致选举新领导人的时间延迟。例如，当领导者 pod 在无响应或者在一个分区的节点上时，<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/#options" target="_blank" rel="noopener"><code>pod-eviction-timeout</code></a> 参数指示从节点删除领导者 pod 时间并下台的时间（默认是5m）。</li>
<li><a href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/leaderelection" target="_blank" rel="noopener">Leader-with-lease</a>：领导者 pod 会定期续签领导租约，并在无法续签租约是放弃领导。这种实现方式可以更快的转移领导权，但是在 <a href="https://github.com/kubernetes/client-go/blob/30b06a83d67458700a5378239df6b96948cb9160/tools/leaderelection/leaderelection.go#L21-L24" target="_blank" rel="noopener">certain situations</a> 可以会出现脑裂的情况。</li>
</ul>
<p>默认情况下，operator SDK 使用 leader-for-life 的方式。但是，你应该参考上述两种方法的文档，以考虑对你的用例有意义的折衷方案。</p>
<p>下面的示例说明了如何使用这两个选项：</p>
<!-- 
### Leader for life

A call to `leader.Become()` will block the operator as it retries until it can become the leader by creating the configmap named `memcached-operator-lock`.
 -->
<h3 id="Leader-for-life"><a href="#Leader-for-life" class="headerlink" title="Leader for life"></a>Leader for life</h3><p>通过对 <code>leader.Become()</code> 方法的调用阻止 operator 重新成为领导，直到其创建名为 <code>memcached-operator-lock</code> 的 configmap。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"github.com/operator-framework/operator-sdk/pkg/leader"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  err = leader.Become(context.TODO(), <span class="string">"memcached-operator-lock"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Error(err, <span class="string">"Failed to retry for leader lock"</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- 
If the operator is not running inside a cluster `leader.Become()` will simply return without error to skip the leader election since it can't detect the operator's namespace.
 -->
<p>如果 operator 不在集群中运行，则 <code>leader.Become()</code> 将返回无错误的消息以跳过领导人选举，因为它无法检测 operator 的命名空间。</p>
<!-- 
### Leader with lease

The leader-with-lease approach can be enabled via the [Manager Options][manager_options] for leader election.
 -->
<h3 id="Leader-with-lease"><a href="#Leader-with-lease" class="headerlink" title="Leader with lease"></a>Leader with lease</h3><p>可以通过 <a href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/manager#Options" target="_blank" rel="noopener">Manager Options</a> 启用领导者租用方式进行领导人选举。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"sigs.k8s.io/controller-runtime/pkg/manager"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  opts := manager.Options&#123;</span><br><span class="line">    ...</span><br><span class="line">    LeaderElection: <span class="literal">true</span>,</span><br><span class="line">    LeaderElectionID: <span class="string">"memcached-operator-lock"</span></span><br><span class="line">  &#125;</span><br><span class="line">  mgr, err := manager.New(cfg, opts)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- 
When the operator is not running in a cluster, the Manager will return an error on starting since it can't detect the operator's namespace in order to create the configmap for leader election. You can override this namespace by setting the Manager's `LeaderElectionNamespace` option.
 -->
<p>当 operator 不在集群中运行时，Manager 将在启动时返回错误，因为它无法检测到 operator 的名称空间以创建用于领导者选举的 configmap。 您可以通过设置 Manager 的 <code>LeaderElectionNamespace</code> 选项来覆盖此命名空间。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-11-29T11:45:41.532Z" itemprop="dateUpdated">2019-11-29 19:45:41</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2019/11/29/operator-user-guide-v0.12/" target="_blank" rel="external">https://luolizhi.github.io/2019/11/29/operator-user-guide-v0.12/</a>
        
    </div>
    
    <footer>
        <a href="https://luolizhi.github.io">
            <img src="/img/leaves7.jpg" alt="lukey">
            lukey
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/operator/">operator</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/11/29/2017-04-21-kubernetes-glusterfs/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">kubernetes glusterfs</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/08/28/helm 安装 logstash/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">helm 安装 logstash 同步mysql数据到elasticsearch</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>lukey &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: false, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '走丢了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
